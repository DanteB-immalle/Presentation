<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <title>reveal-md</title>
        <link rel="stylesheet" href="./css/reveal.css">
        <link rel="stylesheet" href="./css/theme/black.css" id="theme">
        <link rel="stylesheet" href="./css/highlight/zenburn.css">
        <link rel="stylesheet" href="./css/print/paper.css" type="text/css" media="print">

    </head>
    <body>

        <div class="reveal">
            <div class="slides"><section  data-markdown><script type="text/template"><!-- $theme: gaia -->

### Wat zijn optionele parameters?
*zie hoofdstuk 5.10*

Optionele parameters zijn parameters die al een standaardwaarde hebben en daarom **moeten** ze niet gebruikt worden.
</script></section><section  data-markdown><script type="text/template">
**Optionele parameters (voorbeeld):**
```
static void Main(string[] args)
        {
            // Number already has a default value
            PrintTheNumber();
        }

        private static void PrintTheNumber(int number = 0)
        {
            Console.WriteLine("The number is " + number);
        }
```
</script></section><section  data-markdown><script type="text/template">
### Wat is parameter-binding? 
*zie hoofdstuk 5.20*

De argumenten die je bij de aangroep meegeeft worden gekopieerd naar lokale variabelen in de method.
</script></section><section  data-markdown><script type="text/template">
**Parameter-binding (voorbeeld):**
```
static void Main(string[] args)
    	{
    	    int som, verschil;
            SomEnVerschil(15, 50, out som, out verschil);
        }

private static void SomEnVerschil(int getal1, int getal2, out int som, out int verschil)
        {
            som = getal1 + getal2;
            verschil = getal1 - getal2;
        }
```
</script></section><section  data-markdown><script type="text/template">
### Wat is method-overloading?
*zie hoofdstuk 5.22*

Een method kan meerdere overloads hebben. Overloading gebeurt wanneer je twee methods met **dezelfde** naam hebt maar met verschillende parameters. Bij het compilen, gaat de compiler kiezen welke method hij moet gebruiken.
</script></section><section  data-markdown><script type="text/template">
**Method overloading (voorbeeld):**
```
private void Swap(ref int a, ref int b)
        {
            int temp;
            temp = a;
            a = b;
            b = temp;
        }
        private void Swap(ref double a, ref double b)
        {
            double temp;
            temp = a;
            a = b;
            b = temp;
        }
```
</script></section><section  data-markdown><script type="text/template">
### Hoe herken je in WPF event-handlers? 
*zie ook hoofdstuk 5.10*

Event-handlers zijn speciale methods die een *event handlen*. Ze wachten op een bepaalde event, en voeren de method uit als deze event zich voordoet.
**Event-handlers (voorbeeld):**
```
private void button_Click(object sender, RoutedEventArgs e)
        {
            label.Content = textBox.Text;
        }
```
</script></section><section  data-markdown><script type="text/template">
### Waar moet je op letten bij b.v. de `AddYears()`-method van een `DateTime`-object?

`AddYears()` *returnt* enkel een datum. Je moet nog iets met deze waarde doen.
```
DateTime time = new DateTime();
            time = time.AddYears(2);
            /* This is wrong:
             * time.AddYears(2);
             */
```
</script></section><section  data-markdown><script type="text/template">
### Als je een variabele niet initialiseert welke waarde heeft hij dan?

Dit hangt altijd af van het type.
</script></section><section  data-markdown><script type="text/template">
**Value types**

*voorbeelden:*

bool:	false

byte:	0

char:	'\0'

decimal:	0M

double:	0.0D

float:	0.0F
</script></section><section  data-markdown><script type="text/template">
int:	0

long:	0L

sbyte:	0

short:	0

uint:	0

ulong:	0

ushort:	0
</script></section><section  data-markdown><script type="text/template">
**Reference types**

*voorbeelden:*

String

objecten

arrays

lists

Random



</script></section></div>
        </div>

        <script src="./lib/js/head.min.js"></script>
        <script src="./js/reveal.js"></script>

        <script>
            function extend() {
              var target = {};
              for (var i = 0; i < arguments.length; i++) {
                var source = arguments[i];
                for (var key in source) {
                  if (source.hasOwnProperty(key)) {
                    target[key] = source[key];
                  }
                }
              }
              return target;
            }

            // Optional libraries used to extend on reveal.js
            var deps = [
              { src: './lib/js/classList.js', condition: function() { return !document.body.classList; } },
              { src: './plugin/markdown/marked.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/markdown/markdown.js', condition: function() { return !!document.querySelector('[data-markdown]'); } },
              { src: './plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
              { src: './plugin/zoom-js/zoom.js', async: true },
              { src: './plugin/notes/notes.js', async: true },
              { src: './plugin/math/math.js', async: true }
            ];

            // default options to init reveal.js
            var defaultOptions = {
              controls: true,
              progress: true,
              history: true,
              center: true,
              transition: 'default', // none/fade/slide/convex/concave/zoom
              dependencies: deps
            };

            // options from URL query string
            var queryOptions = Reveal.getQueryHash() || {};

            var options = {};
            options = extend(defaultOptions, options, queryOptions);
        </script>


        <script>
            Reveal.initialize(options);
        </script>
    </body>
</html>
